
### 1.```stdint.h```标准头文件
```stdint.h``` 是C99标准引入的标准整数类型头文件，C++中也可用 ```cstdint``` 。具有以下特点：
-  直接定义**固定字节长度**的整数类型，解决原生整数类型在不同平台(32/64位、不同编译器)下的字节长度不固定、**跨平台兼容性**的问题，开发者可**精准控制内存占用**；可按需选择适合长度的类型，从源头上减少溢出风险； 操作硬件寄存器/外设时，寄存器的位宽固定，8位寄存器用 ``uint8_t``` ，精准匹配。

- ```stdint``` 定义的类名命名规律：```[u]int[N]_t``` ，其中u代表无符号，N代表位数/比特位，_t代表这是一个类型定义。
    - ``uint8_t``` ：无符号8位整数，8位1字节；
    - ``int64_t``` ：有符号64位整数，64位8字节。
打印输出时，直接使用普通格式符 ```%d %u```会有兼容性问题或格式错误，这是因为底层映射的不确定性：
- 在多数系统中，```uint8_t``` = ```unsigned char``` ，```int32_t``` = ```int```，```int6_t``` = ```longlong```，但并不绝对，在某些嵌入式系统中，```int32_t``` 可能映射为```long``` 而非```int``` 。
    - 例如：对于 ``int64_t``` ，若直接用 ```%d``` 格式(4字节)打印，会导致内存越界，打印结果错误等问题；
    - 跨平台时，32位系统 ``int64_t```是 ``long long``` (格式符 ``%lld```)，64位系统可能 ``int64_t```是 ``long``` (格式符 ``%ld```)，写死格式符会导致代码在不同平台打印异常。

使用 ```stdint.h``` 配套的格式宏-->根据当前平台自动替换为正确的格式符：
- ```PRIu8``` -->无符号8位整数格式符；
- ```PRId32``` -->有符号32位整数格式符；
- ```PRId64``` -->有符号64位整数格式符.

！使用前需包含头文件**<inttypes.h>**，格式宏本身是字符串，需要双引号包裹。
```c
uint8_t age = 18;
printf("年龄：%"PRIu8"", age);
```
### 2.C语言从源码到可执行文件经历的四个阶段
四个阶段分别是：预处理、编译、汇编、链接
#### （1）预处理器预处理阶段 ```hello.c``` -->```hello.i``` 
该阶段的主要任务是处理带 ```#``` 的语句，包括加载头文件、宏替换、条件编译等。
- 将所有 ```include``` 包含的内容原封不动地拷贝到当前文件中，但会导致重复包含的问题。
##### 头文件重复包含问题
假设你的代码结构如下：
- b.h：声明void func_b();
- a.h：#include "b.h"
- hello.c：#include "a.h" && #include "b.h"
此时 ```void func_b();``` 会被导入两次，若是函数
#### （2）编译器编译阶段 ```hello.i``` -->```hello.s``` 
- 该阶段核心任务是把预处理后的 ```hello.i``` 文件，通过语法分析、语义分析、优化和代码生成，转换成汇编代码 ```hello.s``` 。
- 汇编代码是比c语言更接近硬件的代码，但此文件仍可用文本编辑器打开查看。
    - 语法分析：检查代码是否符合语法规则；
    - 语义分析：检查逻辑合理性，如变量未定义、函数参数类型不匹配；
    - 优化：删除空语句、简化表达式等，无副作用；
    - 代码生成：将C语言代码翻译成对应架构的汇编指令。
#### （3）汇编器汇编阶段 ```hello.s``` -->```hello.o``` 
汇编器将汇编语言翻译成机器认识的机器代码，得到 ```.o``` 为后缀的二进制文件，该文件也称目标文件。
#### （4）链接器链接阶段 ```多个目标文件``` -->```一个可执行文件``` 
- 链接器的工作：将多个目标文件，包括```hello.o``` 目标文件和```printf``` 函数所在的目标文件拼在一起，解决函数/变量的地址引用问题，最终生成一个能直接运行的可执行文件。

汇编得到的```hello.o``` 是一个不完整的目标文件，里面用到了```printf``` 函数，但```printf``` 函数的实现不在```hello.o``` 中，它只存了一个待填充的跳转地址。
链接器会根据代码里的外部引用，去标准库中找到```printf``` 函数所在的目标文件（以及其他依赖的目标文件），将它们合并为一个整体：
- 给每个目标文件里的函数、变量分配最终的内存地址；
- 用对应的内存地址填充跳转地址；
- 把所有目标文件的符号整理成一个全局符号表，确保没有冲突；
- 生成最终的可执行文件，```windows``` 对应```.exe``` 后缀，```linux``` 对应```.out``` 后缀。